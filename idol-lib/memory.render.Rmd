---
title: Memory usage benchmark for Env implementation
output: 
  html_document:
    theme: null
    css: /assets/css/design.css
    self_contained: false
    highlight: null
    include:
      in_header: ../_includes/head.html
      before_body:
        - ../_includes/header.html
        - ../_includes/begin_content.html
        - ../_includes/toc.html
        - ../_includes/begin_post_content.html
      after_body: 
        - ../_includes/handle_page_title.html
        - ../_includes/end_post_content.html
        - ../_includes/end_content.html
        - ../_includes/footer.html
---

```{r echo = FALSE}
library(rmarkdown)
library(kableExtra)
```

## Front matter

This page contains a benchmark on implementation solutions for the Env class in idol. The Env class is used to handle the optimization objects inside idol and to allow one variable to possibly belong to several optimization models. Thus, one variable can belong to multiple model yet each model must have its own "version" of the variable (e.g., lower bound, upper bound, type, etc.). 

When creating a variable inside idol, through the Model::add_var method for instance. A new variable is created inside Env. It is stored inside a vector and has its corresponding index stored as an attribute of Var. Let `Var t_var` be a given variable object, then all of the variable's "versions" can then be accessed via Env::m_variables[t_var.index()]. Given a Model, say `Model t_model`, the task is to access the `t_var`'s version corresponding to `t_model.`, i.e., something like `t_model[t_var]`.

We here test several approaches and test their performance in terms of memory usage and time:

- store the variable's attributes inside an `std::vector<std::unique_ptr<VarAttributes>>` where the indices are those of the model containing the variable ;
- store the variable's attributes inside an `std::map<unsigned int, VarAttributes>` where the key is the id of the model containing the variable ;
- store the variable's attributes inside an `std::unordered_map<unsigned int, VarAttributes>` where the key is the id of the model containing the variable ;

To make this comparison, we assume that the attributes of a variable (e.g., its bounds, its type, etc.) is stored in an `std::array<double, 10>` (this is only not to overly complexify the comparison).

Our test depends on three parameters:

- N_MODELS: the number of different models (values: 1, 5, 10, 20) ;
- N_VARIABLES: the total number of variables (values from 1 to 200000 with a step of 10000) ;
- ODDS_TO_BE_IN_A_MODEL (p, hereafter): the probabilty for a variable to belong to a model (values: .1, .25, .5, .75, 1). For instance, `p = .25` means that each variable belongs to any model with probability .25.

Memory and time usage is measured with `/usr/bin/time`. Memory usage is in Kb and time in ms.

## Raw results

```{r}
dataset = read.csv("result.csv", header = FALSE, sep = ";")
colnames(dataset) = c("method", "n_models", "n_variables", "odds_to_be_in_model", "value", "time", "memory")
```

```{r echo = FALSE}
paged_table(dataset)
```

## Benchmark

```{r fig.show="hold"}
create_plot = function (n_models, odds_to_be_in_model, criteria) {
  
  data = dataset[dataset$n_models == n_models & dataset$odds_to_be_in_model == odds_to_be_in_model,]
  
  with_vector = data[data$method == "with_vector",]
  with_map = data[data$method == "with_map",]
  with_unordered_map = data[data$method == "with_unordered_map",]
  
  ymin = min( data[,criteria] )
  ymax = max( data[,criteria] )
  
  plot(with_vector$n_variables, with_vector[,criteria], type = "l", col = "blue", ylim = c(ymin, ymax), main = paste(criteria, "with", n_models, "models and p =", odds_to_be_in_model), xlab = "n. variables", ylab = criteria)
  lines(with_map$n_variables, with_map[,criteria], col = "red")
  lines(with_unordered_map$n_variables, with_unordered_map[,criteria], col = "green")
  legend(0, ymax, c("vector", "map", "unordered_map"), col = c("blue", "red", "green"), lwd = 1)
}

for (odds_to_be_in_model in unique(dataset$odds_to_be_in_model)) {
  for (n_models in unique(dataset$n_models)) {
    for (criteria in c("memory", "time")) {
      create_plot(n_models, odds_to_be_in_model, criteria)
    }
  }
}

```
