---
layout: page
title: "BibTeX Generator"
---

<i>This is a work in progress... Will work with DOI for sure.</i><br /><br />

<span color="#495057">
  This script generates BibTex entries from DOI, ArXiv or Optimization-Online URLs.
</span>

<style>
  #form {
    margin-top: 20px;
    position: relative;
    display: -ms-flexbox;
    display: flex;
    -ms-flex-wrap: wrap;
    flex-wrap: wrap;
    -ms-flex-align: stretch;
    align-items: stretch;
    width: 100%;
  }

  #bib-button {
    color: #212529;
    background-color: #f8f9fa;
    border: 2px solid #f8f9fa; 
    display: block;
    width: 25%;
    margin-left: 10px;
    border-radius: .25rem;
  }

  #doi-entry {
    display: block;
    width: 70%;
    height: calc(1.5em + .75rem + 2px);
    padding: .375rem .75rem;
    font-size: 1rem;
    font-weight: 400;
    line-height: 1.5;
    color: #495057;
    background-color: #fff;
    background-clip: padding-box;
    border: 1px solid #ced4da;
    border-radius: .25rem;
  }

  #doi-entry:focus {
    color: #495057;
    background-color: #fff;
    border-color: #80bdff;
    outline: 0;
    -webkit-box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
            box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
  }
</style>

<center id="form">
  <input type="text" id="doi-entry" placeholder="Enter a DOI, ArXiv or Optimization Online reference" />
  <input type="button" value="Get BibTex" id="bib-button" />
</center>

<pre style="white-space: pre-wrap;">
  <code id="bib-output" style="display: none;" class="language-latex hljs"></code>
</pre>

<script>
  // Function to prettify BibTeX
  const parseBibTex = (bib) => {
    bib = bib.trim();

    // Match @type{key,
    const headerMatch = bib.match(/^@(\w+)\{([^,]+),/);
    if (!headerMatch) throw new Error("Invalid BibTeX entry");

    const entryType = headerMatch[1];
    const citationKey = headerMatch[2];

    let rest = bib.slice(headerMatch[0].length, bib.lastIndexOf('}')).trim();

    const fields = {};
    let level = 0;       // brace nesting level
    let currentKey = '';
    let currentValue = '';
    let readingKey = true;

    for (let i = 0; i < rest.length; i++) {
      const char = rest[i];

      if (readingKey) {
        if (char === '=') {
          readingKey = false;
        } else {
          currentKey += char;
        }
      } else {
        // Reading value
        if (char === '{') level++;
        if (char === '}') level--;

        currentValue += char;

        // Check if this is the end of the value (top-level comma or end of entry)
        if ((char === ',' && level === 0) || i === rest.length - 1) {
          // Remove trailing comma if present
          currentValue = currentValue.trim().replace(/,$/, '');

          // Remove surrounding braces if present
          if (currentValue.startsWith('{') && currentValue.endsWith('}')) {
            currentValue = currentValue.slice(1, -1).trim();
          }

          fields[currentKey.trim().toLowerCase()] = currentValue.trim();

          // Reset for next field
          currentKey = '';
          currentValue = '';
          readingKey = true;
        }
      }
    }

    return { type: entryType, key: citationKey, fields };
  }

  const formatBibTex = (bibtex) => {
    
    parsed = parseBibTex(bibtex)
    
    const has_doi = "doi" in parsed.fields;
    const fields = {};

    // Filter + sanitize fields
    for (const [k, v] of Object.entries(parsed.fields)) {
      const key = k.toLowerCase();

      // 1. Skip month
      if (key === "month") continue;

      // 2. Skip url if DOI exists
      if (has_doi && key === "url") continue;

      // 3. Replace en-dash with '--'
      const cleanValue = v.replace(/–/g, "--");

      fields[key] = cleanValue;
    }

    // Generate output
    const lines = [];

    // Header: @article{Key,
    lines.push(`@${parsed.type}{${parsed.key},`);

    const entries = Object.entries(fields);
    const lastIndex = entries.length - 1;

    entries.forEach(([k, v], i) => {
      if (i === lastIndex) {
        // Last field → NO COMMA
        lines.push(`  ${k} = {${v}}`);
      } else {
        // Regular field → comma
        lines.push(`  ${k} = {${v}},`);
      }
    });

    lines.push("}");

    return lines.join("\n");
  }

  const getDOI = async doi => {
    
    try {
      
      const response = await fetch(`https://doi.org/${encodeURIComponent(doi)}`, {
        headers: { "Accept": "application/x-bibtex" }
      });

      if (!response.ok) throw new Error(`HTTP error, returned status: ${response.status}.`);
      
      const bibtex = await response.text();
      return bibtex;

    } catch (error) {
      
      console.error(error);
      return "Error fetching BibTeX: " + error
    
    }

  }

  const getOptimizationOnline = async url => {
    
    try {
      let apiUrl
      let params = "_embed"
      
      // Check if URL is ?p=<NUMBER>
      const idMatch = url.match(/\?p=(\d+)/);
      if (idMatch) {
        const postId = idMatch[1];
        apiUrl = `https://optimization-online.org/wp-json/wp/v2/posts/${postId}?${params}`;
      }  else {
        // Otherwise, treat it as /yyyy/mm/slug/
        // Extract slug from URL
        const slugMatch = url.match(/\/\d{4}\/\d{2}\/([^\/]+)\/?$/);
        if (!slugMatch) throw new Error("Cannot extract slug from URL");
        const slug = slugMatch[1];
        apiUrl = `https://optimization-online.org/wp-json/wp/v2/posts/?slug=${slug}&${params}`;
      }
      console.log(apiUrl)
      const response = await fetch(apiUrl)

      if (!response.ok) throw new Error(`HTTP error, returned status: ${response.status}.`);
      
      json = await response.text();
      json = JSON.parse(json)
      if (Array.isArray(json)) {
        if (!json.length) throw new Error("Post not found");
        json = json[0]
      }

      const terms = json["_embedded"]["wp:term"]
      const allTerms = terms.flat();

      const formatName = slug => 
        slug
          .split(/[\._-]/)        // split on dot, underscore, or dash
          .map(s => s.charAt(0).toUpperCase() + s.slice(1))
          .join(" ");

      let authors = terms
        .flat()
        .filter(term => term.taxonomy === "author")
        .map(term => formatName(term.name) || formatName(term.slug))
        .filter(Boolean)
      
      first_author = authors[0]
      first_author = first_author.includes(" ") ? first_author.split(" ").slice(-1)[0] : first_author;
      authors = authors.join(" and ");

      const post = json
      const title = post.title?.rendered || "ERROR"
      const id = post.id || "ERROR"
      const short = post.guid?.rendered || "ERROR"
      const year = new Date(post.date_gmt).getUTCFullYear();
      const tag = `${first_author}${year}`

      return `@misc{${tag}, title={${title}}, author={${authors}}, year={${year}}, archivePrefix={Optimization Online}, url={${short}}}`;

    } catch (error) {

      console.error(error)
      return "Error fetching BibTeX: " + error

    }

  }

  const getArXiv = async (url) => {
    // Extract arXiv ID from URL
    const match = url.match(/\/(\d{4}\.\d{4,5})(v\d+)?/);
    if (!match) throw new Error("Cannot extract arXiv ID");
    const id = match[1];

    const apiUrl = `http://export.arxiv.org/api/query?id_list=${id}`;
    const res = await fetch(apiUrl);
    const text = await res.text();

    alert(text)

    return text;
  }

  $("#bib-button").click(async () => {

    const doi = $("#doi-entry").val().trim();
    const output = $("#bib-output");

    if (!doi) {
      output.text("No DOI/URL was given.");
      return;
    }

    output.css("display", "block")
    output.text("Loading...")

    const isOptimizationOnline = (url) => /^https?:\/\/(www\.)?optimization-online\.org/.test(url);
    const isArXiv = (url) => /^https?:\/\/(www\.)?arxiv\.org\/(abs|pdf)\/\d{4}\.\d{4,5}(v\d+)?/.test(url);

    if (isOptimizationOnline(doi)) {
      text = await getOptimizationOnline(doi)
    } else if (isArXiv(doi)) {
      text = await getArXiv(doi)
    } else {
      text = await getDOI(doi)
    }
    output.text(formatBibTex(text))

  });

  window.addEventListener("DOMContentLoaded", () => {
    $("#doi-entry").focus();
  });

  document.getElementById("doi-entry").addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
      document.getElementById("bib-button").click();
    }
  });
</script>